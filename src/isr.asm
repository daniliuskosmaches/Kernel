; src/isr.asm

extern isr_handler_c
section .text
global isr_irq0
global isr_irq1
global isr_handler_c
global isr_common


; Объявляем внешний C-обработчик (функция в kernel.c или idt.c)


; -------------------------------------------
; Макросос блять для создания оберток прерываний
; %1: Вектор прерывания пениса разраба (например, 0x20)
; -------------------------------------------
%macro ISR_WRAPPER 1
  isr_irq%1:
    push byte 0          ; Эмулируем 'код ошибки' (для IRQ)
    push byte %1         ; Помещаем номер вектора прерывания на стек
    jmp isr_common       ; Переходим к общей логике обработки
%endmacro

; -------------------------------------------
; Обертки для таймера (IRQ 0) и клавиатуры (IRQ 1)
; Смещение PIC - 0x20, поэтому IRQ 0 -> 0x20, IRQ 1 -> 0x21
; -------------------------------------------
ISR_WRAPPER 0x20 ; Таймер
ISR_WRAPPER 0x21 ; Клавиатура

; -------------------------------------------
; Общая логика обработки (C-Call)
; -------------------------------------------
isr_common:
    pusha                ; Сохранить все регистры (EDI, ESI, EBP, ESP, EBX, EDX, ECX, EAX)

    ; Здесь мы должны сохранить сегмент данных,
    ; но для простоты мы предполагаем, что DS = CS (0x08)
    call isr_handler_c

    mov eax, esp         ; EAX = адрес стека с сохраненными регистрами
    push eax             ; Передаем указатель на стек как аргумент C-функции

    call isr_handler_c   ; Вызов обработчика на C

    pop eax              ; Очищаем стек от аргумента (адреса стека)

    popa                 ; Восстановить все регистры

    add esp, 8           ; Очистить стек от номера вектора и кода ошибки (push byte 0, push byte %1)
    iret                 ; Возврат из прерывания (восстанавливает EIP, CS, EFLAGS)