// src/kheap.c
// Файл содержит минимально необходимые заглушки для успешной линковки.

#include "kheap.h"
#define KERNEL_HEAP_START 0xC0000000
// Размер кучи (начнем с небольшого размера, например, 1 МБ)
#define KERNEL_HEAP_SIZE  0x100000 // 1MB
// Конечный адрес кучи
#define KERNEL_HEAP_END (KERNEL_HEAP_START + KERNEL_HEAP_SIZE)
 // Для memset, memcpy, если будут использоваться

// ----------------------------------------------------
// 1. kheap_init (ФУНКЦИЯ, КОТОРАЯ БЫЛА НЕ НАЙДЕНА ЛИНКОВЩИКОМ)
// ----------------------------------------------------

/**
 * Инициализация кучи ядра.
 * Это определение устраняет ошибку линковки 'undefined reference to kheap_init'.
 * ВАШЕ ДЕЙСТВИЕ: ДОБАВИТЬ СЮДА РЕАЛЬНУЮ ЛОГИКУ!
 */
void kheap_init() {
    // Временная заглушка, чтобы линковщик успокоился.
    // Реальная логика здесь будет:
    // 1. Вызвать vmm_allocate_pages() для резервирования места под кучу.
    // 2. Инициализировать структуру для управления свободными блоками.

    // ВНИМАНИЕ: Память пока не выделена и не управляется.
    return;
}


// ----------------------------------------------------
// 2. kmalloc/kfree (ВРЕМЕННЫЕ ЗАГЛУШКИ)
// ----------------------------------------------------

/**
 * Выделяет блок памяти. Пока возвращает NULL.
 */
void* kmalloc(size_t size) {
    (void)size; // Убираем warning: unused parameter
    return 0; // Возвращаем NULL: ЛЮБОЙ вызов выделения памяти ПРОВАЛИТСЯ!
}

/**
 * Освобождает блок памяти. Пока ничего не делает.
 */
void kfree(void* p) {
    (void)p; // Убираем warning: unused parameter
    return;
}

/**
 * Перевыделяет блок памяти. Пока возвращает NULL.
 */
void* krealloc(void* p, size_t new_size) {
    (void)p;
    (void)new_size;
    return 0; // Возвращаем NULL
}